/**
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
  * version 3.0 of the License, or (at your option) any later version.
  *
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
package com.szadowsz.gospel.core.engine.context.goal

import com.szadowsz.gospel.core.data.Term
import com.szadowsz.gospel.core.engine.context.goal.tree.{SubGoalBranch, SubGoalLeaf}

/** Class to hold sub-goal clauses to evaluate
  *
  * Main Constructor takes an existing Sub-Goal Tree generally
  * generated by a ClauseInfo object or static method.
  *
  * @param subGoals The current sub-goals of the demonstration
  */
private[core] class SubGoalStore(subGoals: SubGoalBranch) {
  private var goals: SubGoalBranch = subGoals
  private var index: Int = 0
  private var subGoalId: SubGoalId = _


  def this() = {
    this(new SubGoalBranch())
  }

  def load(subGoals: SubGoalBranch): Boolean = {
    goals = subGoals
    true
  }

  /** Restores the Sub-Goal Store state
    *
    * Backtracks the state to the specified goal pointer so that
    * we can continue our attempts to solve the current theory
    *
    * @param identifier The sub-goal state to backtrack to
    */
  def backTo(identifier: SubGoalId): Option[Term] = {
    popSubGoal(identifier.asInstanceOf[SubGoalId])
    index -= 1 // decrease the index so the term we fetch and return will be correct
    fetch()
  }

  /** Pushes a new sub-goal list onto the stack
    *
    * @param subGoals The sub-goal list to evaluate
    */
  def pushSubGoal(subGoals: SubGoalBranch) {
    subGoalId = SubGoalId(subGoalId, goals, index)
    goals = subGoals
    index = 0
  }

  /** Set an existing identifier as the head and pops all ids that are more recent
    *
    * @param identifier The sub-goal state to go to
    */
  private def popSubGoal(identifier: SubGoalId) {
    goals = identifier.root
    index = identifier.index
    subGoalId = identifier.parent
  }

  /** Returns the next sub-goal to evaluate */
  def fetch(): Option[Term] = {
    if (haveSubGoals) {
      val goal = goals.getChild(index)
      index += 1

      goal match {
        case g: SubGoalBranch =>
          pushSubGoal(g)
          fetch()
        case g: SubGoalLeaf =>
          Option(g.term)
      }
    } else {
      // if we have no more sub-goals we go back up a level if able
      if (subGoalId == null) {
        None
      } else {
        popSubGoal(subGoalId)
        fetch()
      }
    }
  }

  def getSubGoals: SubGoalBranch = goals

  def getIndexNextSubGoal: Int = index

  def getCurrentID: SubGoalId = subGoalId

  /**
    * Current execution index
    */
  def getCurrentIndex: SubGoalId = SubGoalId(subGoalId, goals, index)

  def haveSubGoals: Boolean = index < goals.size

  override def toString: String = "goals: " + goals + " " + "index: " + index
}