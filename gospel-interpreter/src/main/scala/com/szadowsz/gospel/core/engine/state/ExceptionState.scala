/**
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
  * version 3.0 of the License, or (at your option) any later version.
  *
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
package com.szadowsz.gospel.core.engine.state

import java.util

import com.szadowsz.gospel.core.data.{Int, Struct, Term, Var}
import com.szadowsz.gospel.core.engine.context.goal.tree.SubGoalBranch
import com.szadowsz.gospel.core.engine.{Executor, Result}
import com.szadowsz.gospel.core.PrologConverters._

import scala.annotation.tailrec

class ExceptionState extends State {
  
  /**
    * the name of the engine state.
    */
  override protected val stateName: String = "Exception"
  
  private val catchTerm: Term = new Struct("catch",new Var("Goal"),new Var("Catcher"), new Var("Handler"))
  
  override def doJob(e: Executor): Unit = {
    e.currentContext.currentGoal.get.getName match {
      case "throw" => e.nextState = handleInterpreterException(e)
      case _ => e.nextState = handleJavaException(e)
    }
  }
  
  // checks whether the term is a catch mergeable with the argument of the exception thrown
  private def isMergeable(arg1: Term, exceptionTerm: Term): Boolean = {
    if (!arg1.isList || arg1.isEmptyList) {
      false
    } else {
      arg1.asInstanceOf[Struct].getListIterator.exists {
        case element: Struct if element.isCompound && element.getName == "," && element.getArity == 2 =>
          element(0).isUnifiable(exceptionTerm)
        case _ => false
      }
      false
    }
  }
  
  //  Unifies the predicate of java_throw/1 with the right catch statement and returns the corresponding handler
  private def javaUnify(exec : Executor, causeTerm: Struct, exceptionTerm: Term, unifiedVars: util.List[Var]): Option[Term] = {
    val result = causeTerm.getListIterator.find {
      case element: Struct => element.getName == "," && element.getArity == 2 && element(0).isUnifiable(exceptionTerm)
      case _ => false
    }
    
    result.map { case element: Struct =>
      element(0).unify(unifiedVars, unifiedVars, exceptionTerm, exec.isOccursCheckEnabled())
      element(1)
    }
  }
  
 
  private def handleInterpreterException(e: Executor): State = {
    val errorTerm: Term = e.currentContext.currentGoal.get(0)
    recurseForCatchPredicate(e, errorTerm)
  }
  
  private def recurseForCatchPredicate(e: Executor, errorTerm: Term): State = {
    e.currentContext.parent match {
      case None => EndState(Result.HALT)
      case Some(ctx) =>
        e.currentContext = ctx
        if (e.currentContext.currentGoal.get.isUnifiable(catchTerm) && e.currentContext.currentGoal.get(1).isUnifiable(errorTerm)) {
          e.cut() // Cut all choice points generated by the Erroneous Goal
  
          // Unify the argument of throw / 1 with the second argument of Catch / 3
          val unifiedVars: util.List[Var] = e.currentContext.trailingVars.head
          e.currentContext.currentGoal.get(1).unify(unifiedVars, unifiedVars, errorTerm, e.isOccursCheckEnabled())
  
          // insert the manager of the error to the head of the Subgoal list to perform the third argument of
          // catch/3. The manager must also be prepared for maintaining the replacements during the process of
          // unification between the argument of throw/1 and the second argument of catch/3
          var handlerTerm: Term = e.currentContext.currentGoal.get(2)
          val curHandlerTerm: Term = handlerTerm.getBinding
  
          if (!curHandlerTerm.isInstanceOf[Struct]) {
            EndState(Result.FALSE)
          } else {
            // Code inserted to allow evaluation of meta-clause such as p(X) :- X. When evaluating directly terms, they
            // are converted to execution of a call/1 predicate. This enables the dynamic linking of built-ins for terms
            // coming from outside the demonstration context.
            if (handlerTerm ne curHandlerTerm) {
              handlerTerm = new Struct("call", curHandlerTerm)
            }
  
            val handler: Struct = handlerTerm.asInstanceOf[Struct]
            e.identifyPredicate(handler)
            val sgt: SubGoalBranch = new SubGoalBranch
            sgt.addLeaf(handler)
            e.pushSubGoal(sgt)
            e.currentContext.currentGoal = Some(handler)
            new GoalSelectionState
          }
        } else {
          recurseForCatchPredicate(e,errorTerm)
        }
    }
  }
  
  @tailrec
  private def handleJavaException(exec: Executor): State = {
    val javaCatchTerm: Term = "java_catch(Goal, List, Finally)".asPrologTerm(exec.wam)
    val currentGoal = exec.currentContext.currentGoal.get
    val exceptionTerm = currentGoal(0)
    
    // backward tree search for a resolution of Subgoal java_catch/3 whose argument unifies with the Exception thrown
    exec.currentContext.parent match {
      case None => EndState(Result.HALT)

      case Some(_) =>
        // we have identified the ExecutionContext with the proper subgoal java_Catch/3
        if (currentGoal.isUnifiable(javaCatchTerm) && isMergeable(currentGoal(1), exceptionTerm)) {
          handleJavaCatch(exec, currentGoal, exceptionTerm)
        } else { // Step back and try again
          exec.currentContext = exec.currentContext.parent.orNull
          handleJavaException(exec)
        }
    }
  }
  
   private def handleJavaCatch(exec: Executor, currentGoal: Struct, exceptionTerm: Term) = {
    exec.cut() // cut all the choice points generated by JavaGoal
    
    // Unify the topic of java_throw/1 with the appropriate catch
    javaUnify(exec, currentGoal(1).asInstanceOf[Struct], exceptionTerm, exec.currentContext.trailingVars.head) match {
      case None => EndState(Result.FALSE)
      
      case Some(handlerTerm) =>
        
        /** Insert the catch and (if present) finally blocks at the head of the subgoals to perform List. The two
          * predicates must also be prepared for implementing & maintaining the substitutions made during the process 
          * of unification between the exception and the catch block
          */
        val curHandlerTerm = handlerTerm.getBinding
        if (!curHandlerTerm.isInstanceOf[Struct]) {
          EndState(Result.FALSE)
        } else {
          var finallyTerm: Term = currentGoal(2)
          val curFinallyTerm: Term = finallyTerm.getBinding
          
          val isFinally: Boolean = !finallyTerm.isInstanceOf[Int] || finallyTerm.asInstanceOf[Int].intValue != 0
          
          if ((finallyTerm.isInstanceOf[Int] && isFinally) || !curFinallyTerm.isInstanceOf[Struct]) {
            EndState(Result.FALSE)
          } else {
            /** Insert code to allow evaluation of meta-clause such as p(X) :- X. When evaluating directly terms,
              * they are converted to execution of a call/1 predicate. This enables the dynamic linking of built-ins
              * for terms coming from outside the demonstration context.
              */
            val handler: Struct = if (handlerTerm ne curHandlerTerm) new Struct("call", curHandlerTerm) else handlerTerm.asInstanceOf[Struct]
            exec.identifyPredicate(handler)
            val sgt = new SubGoalBranch
            sgt.addLeaf(handler)
            
            if (finallyTerm ne curFinallyTerm) {
              finallyTerm = new Struct("call", curFinallyTerm)
            }
            
            if (isFinally) {
              val finallyStruct: Struct = finallyTerm.asInstanceOf[Struct]
              exec.identifyPredicate(finallyStruct)
              sgt.addLeaf(finallyStruct)
            }
            exec.pushSubGoal(sgt)
            exec.currentContext.currentGoal = Option(handler)
            new GoalSelectionState
          }
        }
    }
  }
}