<html xmlns:concordion="http://www.concordion.org/2007/concordion"
	xmlns:ext="urn:concordion-extensions:2010">
<link href="../../concordion.css" rel="stylesheet" type="text/css" />

<head>
<title>Simple arithmetic functors</title>
</head>

<body>

	<h1>Simple arithmetic functors</h1>

	<p>The basic arithmetic functors are defined as part of the
		evaluable functors which shall be implemented by a standard-conforming
		Prolog processor. Each evaluable functor corresponds to one or more
		operations according to the types of the values which are obtained by
		evaluating the argument(s) of the functor.</p>

	<p>The following list identifies the simple arithmetic functors
		defined as part of the standard:</p>
	<ul>
		<li><code>(+)/2</code></li>
		<li><code>(-)/2</code></li>
		<li><code>(*)/2</code></li>
		<li><code>(//)/2</code> (intdiv)</li>
		<li><code>(/)/2</code> (div)</li>
		<li><code>(rem)/2</code></li>
		<li><code>(mod)/2</code></li>
		<li><code>(-)/1</code></li>
		<li><code>abs/1</code></li>
		<li><code>sign/1</code></li>
		<li><code>float_integer_part/1</code></li>
		<li><code>float_fractional_part/1</code></li>
		<li><code>float/1</code></li>
		<li><code>floor/1</code></li>
		<li><code>truncate/1</code></li>
		<li><code>round/1</code></li>
		<li><code>ceiling/1</code></li>
	</ul>
	<p>Note that the symbols between parentheses are infix predefined
		operators.</p>

	<p>The following list identifies the functors actually exercised by
		this test:</p>
	<ul>
		<li><code>(+)/2</code></li>
		<li><code>(-)/2</code></li>
		<li><code>(*)/2</code></li>
		<li><code>(/)/2</code> (div)</li>
		<li><code>(mod)/2</code></li>
		<li><code>(-)/1</code></li>
		<li><code>abs/1</code></li>
		<li><code>float/1</code></li>
		<li><code>floor/1</code></li>
		<li><code>truncate/1</code></li>
		<li><code>round/1</code></li>
		<li><code>ceiling/1</code></li>
	</ul>

	<h2>Example tests</h2>

	<p>Let's start with some simple tests verifying the value of single
		expressions.</p>

	<p>First of all, let's start an appropriate fixture.</p>

	<table border="1" cellspacing="0" cellpadding="3">
		<tr>
			<td colspan="2">fit.ActionFixture</td>
		</tr>
		<tr>
			<td>start</td>
			<td>alice.tuprolog.EvaluationFixture</td>
		</tr>
	</table>

	<p>Then, ask the engine to evaluate an expression and verify the
		result.</p>

	<table concordion:execute="#result = value(#evaluable)">
		<tr>
			<th concordion:set="#evaluable">Evaluable</th>
			<th concordion:assertEquals="#result">value(String evaluable)</th>
		</tr>
		<tr>
			<td>'+'(7, 35).</td>
			<td>42</td>
		</tr>
		<tr>
			<td>'+'(0, 3+11).</td>
			<td>14</td>
		</tr>
		<tr>
			<td>'+'(0, 3.2+11).</td>
			<td>14.2</td>
		</tr>

		<tr>
			<td>'-'(7).</td>
			<td>-7</td>
		</tr>
		<tr>
			<td>'-'(3-11).</td>
			<td>8</td>
		</tr>
		<tr>
			<td>'-'(3.2-11).</td>
			<td>7.8</td>
		</tr>
		<tr>
			<td>'-'(7, 35).</td>
			<td>-28</td>
		</tr>
		<tr>
			<td>'-'(20, 3+11).</td>
			<td>6</td>
		</tr>
		<tr>
			<td>'-'(0, 3.2+11).</td>
			<td>-14.2</td>
		</tr>
		<tr>
			<td>'*'(7, 35).</td>
			<td>245</td>
		</tr>
		<tr>
			<td>'*'(0, 3+11).</td>
			<td>0</td>
		</tr>
		<tr>
			<td>'*'(1.5, 3.2+11).</td>
			<td>21.299999999999997</td>
		</tr>
		<tr>
			<td>'/'(7, 35).</td>
			<td>0</td>
		</tr>
		<tr>
			<td>'/'(7.0, 35).</td>
			<td>0.2</td>
		</tr>
		<tr>
			<td>'/'(140, 3+11).</td>
			<td>10</td>
		</tr>
		<tr>
			<td>'/'(20.164, 3.2+11).</td>
			<td>1.4200000000000002</td>
		</tr>
		<tr>
			<td>mod(7, 3).</td>
			<td>1</td>
		</tr>
		<tr>
			<td>mod(0, 3+11).</td>
			<td>0</td>
		</tr>
		<tr>
			<td>mod(7, -2).</td>
			<td>-1</td>
		</tr>
		<tr>
			<td>floor(7.4).</td>
			<td>7</td>
		</tr>
		<tr>
			<td>floor(-0.4).</td>
			<td>-1</td>
		</tr>
		<tr>
			<td>round(7.5).</td>
			<td>8</td>
		</tr>
		<tr>
			<td>round(7.6).</td>
			<td>8</td>
		</tr>
		<tr>
			<td>round(-0.6).</td>
			<td>-1</td>
		</tr>

		<tr>
			<td>ceiling(-0.5).</td>
			<td>0</td>
		</tr>
		<tr>
			<td>truncate(-0.5).</td>
			<td>0</td>
		</tr>
		<tr>
			<td>float(7).</td>
			<td>7.0</td>
		</tr>
		<tr>
			<td>float(7.3).</td>
			<td>7.3</td>
		</tr>
		<tr>
			<td>float(5 / 3).</td>
			<td>1.0</td>
		</tr>
		<tr>
			<td>abs(7).</td>
			<td>7</td>
		</tr>
		<tr>
			<td>abs(3-11).</td>
			<td>8</td>
		</tr>
		<tr>
			<td>abs(3.2-11.0).</td>
			<td>7.8</td>
		</tr>




	</table>

	<p>The remaining tests cover the cases when an error or exception
		is thrown by the engine while solving a query.</p>

	<p>First of all, let's start an appropriate fixture containing an
		engine.</p>

	<table
		concordion:execute="#result = successWithException(#goal,#theory)">
		<tr>
			<th concordion:set="#goal">Goal</th>
			<th concordion:set="#theory">Theory</th>
			<th concordion:assertTrue="#result">success(String goal)</th>
			<th ext:embed="successWithExceptionAndText(#goal,#theory)">Type
				Of Error</th>
		</tr>
		<tr>
			<td>current_prolog_flag(max_integer, MI), X is '+'(MI, 1).</td>
			<td>null</td>
			<td>true</td>
			<td></td>
		</tr>
		<tr>
			<td>current_prolog_flag(max_integer, MI), X is '-'('+'(MI, 1),
				1).</td>
			<td>null</td>
			<td>true</td>
			<td></td>
		</tr>
		<tr>
			<td>current_prolog_flag(max_integer, MI), X is '*'(MI, 2).</td>
			<td>null</td>
			<td>true</td>
			<td></td>
		</tr>
		<tr>
			<td>current_prolog_flag(max_integer, MI), R is float(MI) * 2, X
				is floor(R).</td>
			<td>null</td>
			<td>true</td>
			<td></td>
		</tr>


	</table>

</body>
</html>