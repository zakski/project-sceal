package com.szadowsz.gospel.core.engine.state

import java.util.List

import com.szadowsz.gospel.core.data._
import com.szadowsz.gospel.core.engine.subgoal.tree.SubGoalTree
import com.szadowsz.gospel.core.engine.{Engine, EngineRunner}

/**
 * @author Matteo Iuliani
 */
class ExceptionState(protected override val runner : EngineRunner) extends State {
  /**
    * the name of the engine state.
    */
  protected val stateName: String = "Exception"

  private[gospel] final val catchTerm: Term = Term.createTerm("catch(Goal, Catcher, Handler)")
  private[gospel] final val javaCatchTerm: Term = Term.createTerm("java_catch(Goal, List, Finally)")

  private[gospel] def doJob(e: Engine) {
    val errorType: String = e.context.currentGoal.getName
    if (errorType == "throw")
      prologException(e)
    else
      javaException(e)
  }

  private def prologException(e: Engine) {
    val errorTerm: Term = e.context.currentGoal.getArg(0)
    e.context = e.context.fatherCtx

    // step to the halt state if the error cannot be handled
    if (e.context == null) {
      e.nextState = runner.END_HALT
      return
    }

    while (true) {  // backward tree search for a resolution of Subgoal catch/3 whose second argument unifies with the Exception thrown

      // we have identified the ExecutionContext with the proper subgoal Catch/3
      if (e.context.currentGoal.matches(catchTerm) && e.context.currentGoal.getArg(1).matches(errorTerm)) {
        runner.cut // Cut all choice points generated by the Erroneous Goal

        // Unify the argument of throw / 1 with the second argument of Catch / 3
        val unifiedVars: List[Var] = e.context.trailingVars.getHead
        e.context.currentGoal.getArg(1).unify(unifiedVars, unifiedVars, errorTerm)


        // insert the manager of the error to the head of the Subgoal list
        // to perform the third argument of catch/3. The manager must
        // also be prepared for maintaining the replacements during the process of
        // unification between the argument of throw/1 and the second argument of catch/3
        var handlerTerm: Term = e.context.currentGoal.getArg(2)
        val curHandlerTerm: Term = handlerTerm.getTerm

        // step to the halt state if the error cannot be handled
        if (!(curHandlerTerm.isInstanceOf[Struct])) {
          e.nextState = runner.END_FALSE
          return
        }

        // Code inserted to allow evaluation of meta-clause
        // such as p(X) :- X. When evaluating directly terms,
        // they are converted to execution of a call/1 predicate.
        // This enables the dynamic linking of built-ins for
        // terms coming from outside the demonstration context.
        if (handlerTerm ne curHandlerTerm)
          handlerTerm = new Struct("call", curHandlerTerm)

        val handler: Struct = handlerTerm.asInstanceOf[Struct]
        runner.identify(handler)
        val sgt: SubGoalTree = new SubGoalTree
        sgt.addLeaf(handler)
        runner.pushSubGoal(sgt)
        e.context.currentGoal = handler
        e.nextState = runner.GOAL_SELECTION
        return

      } else {
        // step to the halt state if the error cannot be handled
        e.context = e.context.fatherCtx
        if (e.context == null) {
          e.nextState = runner.END_HALT
          return
        }
      }
    }
  }

  private def javaException(e: Engine) {
    val exceptionTerm: Term = e.context.currentGoal.getArg(0)
    e.context = e.context.fatherCtx

    // step to the halt state if the error cannot be handled
    if (e.context == null) {
      e.nextState = runner.END_HALT
      return
    }

    while (true) {  // backward tree search for a resolution of Subgoal java_catch/3 whose argument unifies with the Exception thrown

      // we have identified the ExecutionContext with the proper subgoal java_Catch/3
      if (e.context.currentGoal.matches(javaCatchTerm) && javaMatch(e.context.currentGoal.getArg(1), exceptionTerm)) {
        runner.cut // cut all the choice points generated by JavaGoal

        // Unify the topic of java_throw/1 with the appropriate catch
        val unifiedVars: List[Var] = e.context.trailingVars.getHead
        var handlerTerm: Term = javaUnify(e.context.currentGoal.getArg(1), exceptionTerm, unifiedVars)
        if (handlerTerm == null) {
          e.nextState = runner.END_FALSE
          return
        }

        // Insert the catch and (if present) finally blocks at the head of
        //  the subgoals to perform List. The two predicates must also
        // be prepared for implementing & maintaining the substitutions
        // Made during the process of unification between
        // The exception and the catch block
        val curHandlerTerm: Term = handlerTerm.getTerm
        if (!(curHandlerTerm.isInstanceOf[Struct])) {
          e.nextState = runner.END_FALSE
          return
        }
        var finallyTerm: Term = e.context.currentGoal.getArg(2)
        val curFinallyTerm: Term = finallyTerm.getTerm

        // check if we have a finally block
        var isFinally: Boolean = true
        if (curFinallyTerm.isInstanceOf[numeric.Int]) {
          val finallyInt: numeric.Int = curFinallyTerm.asInstanceOf[numeric.Int]
          if (finallyInt.intValue == 0){
            isFinally = false
          } else { // syntax error
            e.nextState = runner.END_FALSE
            return
          }
        } else if (!(curFinallyTerm.isInstanceOf[Struct])) {
          e.nextState = runner.END_FALSE
          return
        }

        // Code inserted to allow evaluation of meta-clause
        // such as p(X) :- X. When evaluating directly terms,
        // they are converted to execution of a call/1 predicate.
        // This enables the dynamic linking of built-ins for
        // terms coming from outside the demonstration context.
        if (handlerTerm ne curHandlerTerm)
          handlerTerm = new Struct("call", curHandlerTerm)
        if (finallyTerm ne curFinallyTerm)
          finallyTerm = new Struct("call", curFinallyTerm)

        val handler: Struct = handlerTerm.asInstanceOf[Struct]
        runner.identify(handler)
        val sgt: SubGoalTree = new SubGoalTree
        sgt.addLeaf(handler)
        if (isFinally) {
          val finallyStruct: Struct = finallyTerm.asInstanceOf[Struct]
          runner.identify(finallyStruct)
          sgt.addLeaf(finallyStruct)
        }
        runner.pushSubGoal(sgt)
        e.context.currentGoal = handler
        e.nextState = runner.GOAL_SELECTION
        return
      }
      else {
        e.context = e.context.fatherCtx
        if (e.context == null) {
          e.nextState = runner.END_HALT
          return
        }
      }
    }
  }
  // checks whether the term is a catch mergeable with the argument of the exception thrown
  private def javaMatch(arg1: Term, exceptionTerm: Term): Boolean = {
    if (!arg1.isList) return false
    val list: Struct = arg1.asInstanceOf[Struct]
    if (list.isEmptyList) return false
    val it = list.iterator
    while (it.hasNext) {
      val nextTerm: Term = it.next
      if (nextTerm.isCompound){
        val element: Struct = nextTerm.asInstanceOf[Struct]

        if ((element.getName == ",")&& element.getArity == 2){
          if (element.getArg(0).matches(exceptionTerm)) {
            return true
          }
        }
      }
    }
    return false
  }
  //  Unifies the predicate of java_throw/1 with the right catch statement and returns the corresponding handler
  private def javaUnify(arg1: Term, exceptionTerm: Term, unifiedVars: List[Var]): Term = {
    val list: Struct = arg1.asInstanceOf[Struct]
    val it: Iterator[_ <: Term] = list.iterator.filter(_.isCompound)
    for (nextTerm <- it) {
      val element: Struct = nextTerm.asInstanceOf[Struct]
      if ((element.getName == ",")&& element.getArity == 2){
        if (element.getArg(0).matches(exceptionTerm)) {
          element.getArg(0).unify(unifiedVars, unifiedVars, exceptionTerm)
          return element.getArg(1)
        }
      }
    }
    return null
  }
}