package com.szadowsz.gospel.core.engine.subgoal

import com.szadowsz.gospel.core.data.Term
import com.szadowsz.gospel.core.engine.subgoal.tree.{SubGoalLeaf, SubGoalTree}

/** Class to hold sub-goal clauses to evaluate
  *
  * Main Constructor takes an existing Sub-Goal Tree generally
  * generated by a ClauseInfo object or static method.
  *
  * @param subGoals The current sub-goals of the demonstration
  */
private[engine] class SubGoalStore(subGoals: SubGoalTree) {
  private var _goals   : SubGoalTree = subGoals
  private var _index   : Int = 0
  private var _curSGId : SubGoalId = null

  /** Restores the Sub-Goal Store state
    *
    * Backtracks the state to the specified goal pointer so that
    * we can continue our attempts to solve the current theory
    *
    * @param identifier The sub-goal state to backtrack to
    */
  def backTo(identifier: SubGoalId): Option[Term] = {
    popSubGoal(identifier.asInstanceOf[SubGoalId])
    _index -= 1 // decrease the index so the term we fetch and return will be correct
    fetch()
  }

  /** Pushes a new sub-goal list onto the stack
    *
    * @param subGoals The sub-goal list to evaluate
    */
  def pushSubGoal(subGoals: SubGoalTree) {
    _curSGId = new SubGoalId(_curSGId, _goals, _index)
    _goals = subGoals
    _index = 0
  }

  /** Set an existing identifier as the head and pops all ids that are more recent
    *
    * @param identifier The sub-goal state to go to
    */
  private def popSubGoal(identifier: SubGoalId) {
    _goals = identifier.getRoot
    _index = identifier.getIndex
    _curSGId = identifier.getParent
  }

  /** Returns the next sub-goal to evaluate */
  def fetch(): Option[Term] = {
    if (haveSubGoals) {
      val goal = _goals.getChild(_index)
      _index += 1

      goal match {
        case g : SubGoalTree =>
          pushSubGoal(g)
          fetch()
        case g : SubGoalLeaf =>
          Option(g.getValue)
      }
    } else { // if we have no more sub-goals we go back up a level if able
      if (_curSGId == null) {
        None
      } else {
        popSubGoal(_curSGId)
        fetch()
      }
    }
  }

  def getCurrentID: SubGoalId = _curSGId
  
  /**
   * Current execution index
   */
  def getCurrentIndex: SubGoalId = new SubGoalId(_curSGId, _goals, _index)

  def haveSubGoals: Boolean = _index < _goals.size

  override def toString: String = "goals: " + _goals + " " + "index: " + _index
}