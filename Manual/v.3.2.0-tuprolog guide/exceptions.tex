%=======================================================================
\chapter{\tuprolog{} Exceptions}
ss\label{ch:exceptions}
%=======================================================================

%=======================================================================
\section{Exceptions in ISO Prolog}
\label{sec:exceptions in ISO prolog}
%=======================================================================
Exception handling was first introduced in the ISO Prolog standard (ISO/IEC 13211-1) in 1995.

The first distinction has to be made between \textit{errors} and \textit{exceptions}.
%
An \textit{error} is a particular circumstance that interrupts the execution of a Prolog program: when a Prolog engine encounters an error, it raises an \textit{exception}.
%
The exception handling support is supposed to intercept the exception and transfer the execution flow to a suitable exception handler, with any relevant information. Two basic principles are followed during this operation:

\begin{itemize}
  \item \textit{error bounding} -- an error must be bounded and not propagate through the entire program: in particular, an error occurring inside a given component must either be captured at the component's frontier, or remain invisible and be reported nicely.
      According to ISO Prolog, this is done via the \texttt{catch/3} predicate.

  \item \textit{atomic jump} -- the exception handling mechanism must be able to exit atomically from any number of nested execution contexts. According to ISO Prolog, this is done via the \texttt{throw/1} predicate.
\end{itemize}
%
In practice, the \texttt{catch(\textit{Goal}, \textit{Catcher}, \textit{Handler})} predicate enables the controlled execution of a goal, while the \texttt{throw(\textit{Error})} predicates makes it possible to raise an exception---very much like the \texttt{try/catch} construct of many imperative languages.

Semantically, executing the \texttt{catch(\textit{Goal}, \textit{Catcher}, \textit{Handler})} means that \texttt{\textit{Goal}} is first executed: if an error occurs, the subgoal where the error occurred is replaced by the corresponding \texttt{throw(\textit{Error})}, which raises the exception.
%
Then, a matching \texttt{catch/3} clause -- that is, a clause whose second argument
unifies with \texttt{\textit{Error}} -- is searched among the ancestor nodes in the resolution tree: if one is found, the path in the resolution tree is cut, the catcher itself is removed (because it only applies to the protected goal, not to the handler), and the \texttt{\textit{Handler}} predicate is executed. If, instead, no such matching clause is found, the execution simply fails.

So, \texttt{catch(\textit{Goal}, \textit{Catcher}, \textit{Handler})} performs exactly like \texttt{\textit{Goal}} if no exception are raised: otherwise, all the choicepoints generated by \texttt{\textit{Goal}} are cut, a matching \texttt{\textit{Catcher}} is looked for, and if one is found \texttt{\textit{Handler}} is executed, maintaining the substitutions made during the previous unification process.
%
Then, execution continues with the subgoal following \texttt{catch/3}.
%
Any side effects possibly occurred during the execution of a goal are \textit{not} undone in case of exceptions---as it normally happens when a predicate fails.

Summing up, \texttt{catch/3} succeeds if:
\begin{itemize}
  \item \texttt{call(\textit{Goal})} succeeds \textit{(standard behaviour)};\\\\
        --OR--
  \item \texttt{call(\textit{Goal})} is interrupted by a call to
      \texttt{throw(\textit{Error})} whose \texttt{\textit{Error}} unifies with
      \texttt{\textit{Catcher}}, and the subsequent \texttt{call(\textit{Handler})} succeeds.
\end{itemize}

\noindent If \texttt{\textit{Goal}} is non-deterministic, it can be executed again in
backtracking. However, since all the choicepoints of \texttt{\textit{Goal}} are cut in case of exception, \texttt{\textit{Handler}} \textit{is possibly executed just once}.

\smallskip

\noindent As an example, let us consider the following toy program:
\begin{verbatim}
    p(X):- throw(error), write('---').
    p(X):- write('+++').
\end{verbatim}

\noindent with the following query:

\begin{verbatim}
    ?:- catch(p(0), E, write(E)), fail.
\end{verbatim}
which tries to execute \texttt{p(0)}, catching any exception \texttt{E} and handling the error by just printing it on the standard output (\texttt{write(E)}).

Perhaps surprisingly, the program will just print \texttt{'error'}, not \texttt{'error---'} or \texttt{'error+++'}. The reason is that once the exception is raised, the execution of \texttt{p(X)} is aborted, and after the handler terminates the execution proceeds with the subgoal following \texttt{catch/3}, i.e. \texttt{fail}.
So, \texttt{write('---')} is never reached, nor is \texttt{write('+++')} since all the choicepoints are cut upon exception.

%-----------------------------------------------------------------------
\subsection{Error classification}
%-----------------------------------------------------------------------
This classification was already presented in Section \ref{sec:exception-support} above as a hint to predicate and functor readability: however, we report it here too both for completeness and for the reader's convenience.

When an exception is raised, the relevant error information is also transferred by instantiating a suitable \textit{error term}.

The ISO Prolog standard prescribes that such a term follows the pattern
\texttt{error(\textit{Error\_term}, \textit{Implementation\_defined\_term})} where
\texttt{\textit{Error\_term}} is constrained by the standard to a pre-defined set of values (the error categories), and \texttt{\textit{Implementation\_defined\_term}} is an optional term providing implementation-specific details.
%
Ten error categories are defined:
\begin{enumerate}
  \item \texttt{instantiation\_error}: when the argument of a predicate or one of its components is an unbound variable, which should have been instantiated. Example: \texttt{X is Y+1} when \texttt{Y} is not instantiated at the time \texttt{is/2} is evaluated.

  \item \texttt{type\_error(\textit{ValidType}, \textit{Culprit})}: when the type of an argument of a predicate, or one of its components, is instantiated, but is bound to the wrong type of data. \texttt{\textit{ValidType}} represents the expected data type (one of \texttt{atom}, \texttt{atomic}, \texttt{byte}, \texttt{callable}, \texttt{character}, \texttt{evaluable}, \texttt{in\_byte}, \texttt{in\_character}, \texttt{integer}, \texttt{list}, \texttt{number}, \texttt{predicate\_indicator}, \texttt{variable}), and \texttt{\textit{Culprit}} is the actual (wrong) type found.
      Example: a predicate expecting months to be represented as integers in the range 1--12 called with an argument like \texttt{march} instead of \texttt{3}.

  \item \texttt{domain\_error(\textit{ValidDomain}, \textit{Culprit})}: when the argument type is correct, but its value falls outside the expected range.
      \texttt{\textit{ValidDomain}} is one of \texttt{character\_code\_list},
      \texttt{not\_empty\_list}, \texttt{not\_less\_than\_zero}, \texttt{close\_option}, \texttt{io\_mode}, \texttt{operator\_priority}, \texttt{operator\_specifier}, \texttt{flag\_value}, \texttt{prolog\_flag}, \texttt{read\_option}, \texttt{write\_option}, \texttt{source\_sink}, \texttt{stream}, \texttt{stream\_option}, \texttt{stream\_or\_alias}, \texttt{stream\_position},\\
      \texttt{stream\_property}. Example: a predicate expecting months as above, called with an out-of-range argument like \texttt{13}.

  \item \texttt{existence\_error(\textit{ObjectType}, \textit{ObjectName}}): when the referenced object does not exist. \texttt{\textit{ObjectType}} is
      the type of the unexisting object (one of \texttt{procedure}, \texttt{source\_sink}, or \texttt{stream}), and \texttt{\textit{ObjectName}} is the missing object's name. Example: trying to access an unexisting file like \texttt{usr/goofy} leads to an
      \texttt{existence\_error(stream, 'usr/goofy')}.

  \item \texttt{permission\_error(\textit{Operation}, \textit{ObjectType}, \textit{Object})}: whenever\\
       \texttt{\textit{Operation}} (one of \texttt{access}, \texttt{create}, \texttt{input}, \texttt{modify}, \texttt{open}, \texttt{output}, or \texttt{reposition}) is not allowed on \texttt{\textit{Object}}, of type \texttt{\textit{ObjectType}} (one of  \texttt{binary\_stream}, \texttt{past\_end\_of\_stream}, \texttt{operator}, \texttt{private\_procedure}, \texttt{static\_procedure}, \texttt{source\_sink}, \texttt{stream}, \texttt{text\_stream}, \texttt{flag}).

  \item \texttt{representation\_error(\textit{Flag})}: when an implementation-defined limit, whose category is given by \texttt{\textit{Flag}} (one of
      \texttt{character}, \texttt{character\_code}, \texttt{in\_character\_code}, \texttt{max\_arity}, \texttt{max\_integer}, \texttt{min\_integer}), is violated during execution.

  \item \texttt{evaluation\_error(\textit{Error})}: when the evaluation of a function produces an out-of-range value (one of \texttt{float\_overflow}, \texttt{int\_overflow}, \texttt{undefined}, \texttt{underflow}, \texttt{zero\_divisor}).

  \item \texttt{resource\_error(\textit{Resource})}: when the Prolog engine does not have enough resources to complete the execution of the goal. \texttt{Resource} can be any term useful to describe the situation. Examples: maximum number of opened files reached, no further available memory, etc.

  \item \texttt{syntax\_error(\textit{Message})}: when data read from an external source have an incorrect format or cannot be processed for some reason. \texttt{\textit{Message}} can be any term useful to describe the situation.

  \item \texttt{system\_error}: any other unexpected error not falling into the previous categories.
\end{enumerate}

%=======================================================================
\section{Exceptions in \tuprolog}
\label{sec:exceptions in tuprolog}
%=======================================================================

\tuprolog{} aims to fully comply to ISO Prolog exceptions.
%
In the following, a set of mini-examples are presented which highlight each one single aspect of \tuprolog{} compliance to the ISO standard.

%-----------------------------------------------------------------------
\subsection{Examples}
%-----------------------------------------------------------------------

\medskip\noindent
\textit{\textbf{Example 1:} \texttt{Handler} must be executed maintaining the substitutions made during the unification process between \texttt{Error} and \texttt{Catcher}}

Program: \texttt{p(0) :- throw(error).}

Query: \texttt{ ?- catch(p(0), E, atom\_length(E, Length)).}

Answer: \texttt{ yes.}

Substitutions: \texttt{E/error}, \texttt{Length/5}


\medskip\noindent
\textit{\textbf{Example 2:} the selected \texttt{Catcher} must be the nearest in the resolution tree whose second argument unifies with \texttt{Error}}

Program: \texttt{p(0) :- throw(error).}\\
\mbox{\texttt{~~~~~~~~~~~}}\texttt{p(1).}

Query: \texttt{ ?- catch(p(1), E, fail),  catch(p(0), E, true).}

Answer: \texttt{ yes.}

Substitutions: \texttt{E/error}


\medskip\noindent
\textit{\textbf{Example 3:} execution must fail if an error occurs during a goal execution and there is no matching \texttt{catch/3} predicate whose second argument unifies with \texttt{Error}}

Program: \texttt{p(0) :- throw(error).}

Query: \texttt{ ?- catch(p(0), error(X), true).}

Answer: \texttt{ no.}


\medskip\noindent
\textit{\textbf{Example 4:} execution must fail if \texttt{Handler} is false}

Program: \texttt{p(0) :- throw(error).}

Query: \texttt{ ?- catch(p(0), E, false).}

Answer: \texttt{ no.}


\medskip\noindent
\textit{\textbf{Example 5:} if \texttt{Goal} is non-deterministic, it is executed again on backtracking, but in case of exception all the choicepoints must be cut, and \texttt{Handler} must be executed only once}

Program: \texttt{p(0).}\\
\mbox{\texttt{~~~~~~~~~~~}}\texttt{p(1) :- throw(error).}\\
\mbox{\texttt{~~~~~~~~~~~}}\texttt{p(2).}

Query: \texttt{ ?- catch(p(X), E, true).}

Answer: \texttt{ yes.}

Substitutions: \texttt{X/0}, \texttt{E/error}

Choice: \texttt{ Next solution?}

Answer: \texttt{ yes.}

Substitutions: \texttt{X/1}, \texttt{E/error}

Choice: \texttt{ Next solution?}

Answer: \texttt{ no.}


\medskip\noindent
\textit{\textbf{Example 6:} execution must fail if an exception occurs in \texttt{Handler}}

Program: \texttt{p(0) :- throw(error).}

Query: \texttt{ ?- catch(p(0), E, throw(err)).}

Answer: \texttt{ no.}

%-----------------------------------------------------------------------
\subsection{Handling Java/.NET Exceptions from \tuprolog}
\label{ssec:java-exceptions-in-tuprolog}
%-----------------------------------------------------------------------

One peculiar aspect of \tuprolog{} is the ability to support multi-paradigm programming, mixing object-oriented (mainly, but not exclusively, Java) and Prolog in several ways---in particular, by enabling Java objects to be accessed and exploited from Prolog world via OOLibrary (see Section \ref{sec:java-library}) and by enabling .NET objects to be accessed and exploited from Prolog world via OOLibrary (see Section \ref{sec:dotnet-oolibrary})
%
In this context, the problem arises of properly sensing and handling Java/.NET exceptions from the Prolog side.

At a first sight, one might think of re-mapping such exceptions and constructs onto the Prolog ones, but this approach is unsatisfactory for three reasons:
%
\begin{itemize}
  \item the semantics of the Java/.NET mechanism should not be mixed with the Prolog one, and vice-versa;

  \item the Java/.NET construct admits also a \texttt{finally} clause which has no counterpart in ISO Prolog exceptions;

  \item the Java/.NET catching mechanisms operates hierarchically, while the \texttt{catch/3} predicate operates via pattern matching and unification, allowing for a finer-grain, more flexibly exception filtering.
\end{itemize}

%\noindent Accordingly, Java/.NET exceptions in \tuprolog{} programs are handled by means of two further, \textit{ad hoc} predicates: \texttt{java\_throw/1} and \texttt{java\_catch/3} in the Java case, and \texttt{oo\_throw/1} and \texttt{oo\_catch/3} in the .NET case, respectively.
%%
%Since their behavior can be fully understood only in the context of JavaLibrary/OOLibrary, we forward the reader to Sections \ref{sec:java-library} and \ref{sec:dotnet-oolibrary}, respectively, for further information.
%
\noindent Accordingly, Java/.NET exceptions in \tuprolog{} programs are handled by means of an \textit{ad hoc} predicate, called \texttt{java\_catch/3} in the Java case and \texttt{oo\_catch/3} in the .NET case, respectively.
%
Since their behavior can be fully understood only in the context of OOLibrary, we forward the reader to Sections \ref{sec:java-library} and \ref{sec:dotnet-oolibrary}, respectively, for further information.

%%---------------------------------------------------------------------------------------
%\section*{Appendix: Implementation notes}
%%---------------------------------------------------------------------------------------
%
%Implementing exceptions in \tuprolog{} does not mean just to extend the engine to support the above mechanisms: given its library-based design, and its intrinsic support to multi-paradigm programming, adding exceptions in \tuprolog{} has also meant (1) to revise all the existing libraries, modifying any library predicate so that it raises the appropriate type of exception instead of just failing; and (2) to carefully define and implement a model to make Prolog exceptions not only coexist, but also fruitfully operate with the Java or .NET imperative world, which brings its own concept of exception and its own handling mechanism.
%
%As a preliminary step, the finite-state machine which constitutes the core of the \tuprolog{} engine was extended with a new \textit{Exception} state, between the existing \textit{Goal Evaluation} and \textit{Goal Selection} states \cite{iuliani-masterthesis-2009}.
%
%Then, all the \tuprolog{} libraries were revised, according to clearness and efficiency criteria --- that is, the introduction of the new checks required for proper exception raising should not reduce performance unacceptably. This issue was particularly relevant for runtime checks, such as \texttt{existence\_error}s or \texttt{evaluation\_error}s; moreover, since \tuprolog{} libraries could also be implemented partly in Prolog and partly in Java, careful choices had to be made so as to introduce such checks at the most adequate level in order to intercept all errors while maintaining code readability and overall organisation, while guaranteeing efficiency.
%
%This led to intervene with extra Java checks for libraries fully implemented in Java, and with new ''Java guards'' for predicates implemented in Prolog, keeping the use of Prolog meta-predicates (such as \texttt{integer/1}) to a minimum.
%
%\bigskip
%
%Per quel che riguarda il modo in cui \`{e} stato implementato il meccanismo di controllo degli errori, bisogna distinguere i predicati espressi in Java da quelli espressi in Prolog.
%
%Nel primo caso le eccezioni (cio\`{e} le opportune istanze di \texttt{PrologError}) vengono lanciate direttamente dai corrispondenti metodi Java ogniqualvolta si verifica un errore, mentre nel secondo caso sono lanciate da metodi ``guardia" (sempre espressi in Java) invocati per controllare i parametri prima dell'esecuzione del predicato Prolog.
%
%Nell'implementazione si \`{e} cercato di individuare il maggior numero possibile di condizioni di errore, rispettando per\`{o} sempre il requisito fondamentale di correttezza: se una chiamata a un predicato non falliva prima dell'introduzione del meccanismo delle eccezioni, non deve fallire neanche ora---ovvero, il lancio di una eccezione deve avvenire soltanto in circostanze in cui il motore tuProlog originario falliva.
%
%La correttezza del comportamento del motore \`{e} garantita anche se ci si dimentica di identificare qualche condizione di errore inaspettata: in questo caso infatti il motore non lancia un'eccezione, ma comunque fallisce.
%%
%Ci\`{o} permette ad un utente sia di gestire gli errori che si possono verificare durante l'esecuzione, sia di non gestirli, nel qual caso l'esecuzione fallir\`{a} e dunque l'estensione rester\`{a} trasparente.
%
%A parte le inevitabili modifiche ai built-in e alle librerie (\textit{BasicLibrary}, \textit{ISOLibrary}, \textit{IOLibrary}, \textit{DCGLibrary}), sono state necessarie le seguenti semplici modifiche al motore:
%
%\begin{itemize}
%
%\item alla classe \texttt{alice.tuprolog.FlagManager} sono stati aggiunti due metodi per ricavare informazioni su un flag:
%
%\begin{itemize}
%\item \texttt{boolean isModifiable(String name)}\\
%        che restituisce true se esiste nel motore un flag di nome \texttt{name}, e tale flag \`{e} modificabile;
%
%\item \texttt{boolean isValidValue(String name, Term Value)}\\
%        che restituisce true se esiste nel motore un flag di nome \texttt{name}, e \texttt{Value} \`{e} un valore ammissibile per tale flag.
%\end{itemize}
%
%  \item il metodo \texttt{getEngineManager} della classe \texttt{alice.tuprolog.Prolog} \`{e} ora pubblico (in precedenza aveva visibilit\`{a} di package) per permettere alle librerie di ricavare dal motore l'informazione sul goal correntemente in esecuzione e inserirla nell'eccezione lanciata;
%
%  \item il metodo \texttt{evalAsFunctor} della classe \texttt{alice.tuprolog.PrimitiveInfo} lancia ora un'istanza di \texttt{Throwable} in caso di errore durante la valutazione del goal, mentre prima ritornava \texttt{null}, per permettere di discriminare il tipo di errore verificatosi durante la valutazione di un funtore;
%
%  \item analogamente, il metodo \texttt{evalExpression} di \texttt{alice.tuprolog.Library} rilancia ora l'istanza di \texttt{Throwable} ricevuta dal metodo \texttt{evalAsFuntor} di \texttt{alice.tuprolog.PrimitiveInfo}.
%\end{itemize}

