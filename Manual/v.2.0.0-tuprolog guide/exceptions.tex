%=======================================================================
\chapter{Exceptions}
\label{exceptions}
%=======================================================================

This chapter describes the new support for exceptions in \tuprolog{}.

%=======================================================================
\section{Exceptions in ISO Prolog}
\label{sec:exceptions in ISO prolog}
%=======================================================================
The ISO Prolog standard (ISO/IEC 13211-1) has been published in 1995. Among the many additions, it
introduces the \texttt{catch/3} e \texttt{throw/1} constructs for exception handling.
%
The first distinction has to be made between \textit{errors} and \textit{exceptions}. An error is
a particular circumstance that interrupts the execution of a Prolog program: when a Prolog engine
encounters an error, it raises an exception. The exception handling support is supposed to
intercept the exception and transfer the execution flow to a suitable exception handler, with any
relevant information. Two basic principles are followed during this operation:
\begin{itemize}
  \item \textit{error bounding} -- an error must be bounded and not propagate through the
      entire program: in particular, an error occurring inside a given component must either
      be captured at the component's frontier, or remain invisible and be reported nicely.
      According to ISO Prolog, this can be done via the \texttt{catch/3} predicate.
  \item \textit{atomic jump} -- the exception handling mechanism must be able to exit
      atomically from any number of nested execution contexts. According to ISO Prolog, this
      is done via the \texttt{throw/1} predicate.
\end{itemize}
%
In practice, \texttt{throw(\textit{Error})} raises an exception, while the controlled execution of
a goal is launched via the \texttt{catch(\textit{Goal}, \textit{Catcher}, \textit{Handler})}
predicate, which is very much like the \texttt{try/catch} construct of many imperative languages.
%
Here, \texttt{\textit{Goal}} is first executed: if an error occurs, the subgoal where the error
occurred is replaced by the corresponding \texttt{throw(\textit{Error})}, which raises the
exception. Then, a matching \texttt{catch/3} clause -- that is, a clause whose second argument
unifies with \texttt{\textit{Error}} -- is searched among the antenate nodes in the resolution
tree: if one is found, the path in the resolution tree is cut, the catcher itself is removed
(because it only applies to the protected goal, not to the handler), and the
\texttt{\textit{Handler}} predicate is executed. If, instead, no such matching clause is found,
the execution simply fails.
%
So, \texttt{catch(\textit{Goal}, \textit{Catcher}, \textit{Handler})} performs exactly like
\texttt{\textit{Goal}} if no exception are raised: otherwise, all the choicepoints generated by
\texttt{\textit{Goal}} are cut, a matching \texttt{\textit{Catcher}} is looked for, and if a one
is found then \texttt{\textit{Handler}} is executed, maintaining the substitutions made during the
previous unification process.
%
In the very end, the execution continues with the subgoal which follows \texttt{catch/3}.
%
However, any side effects possibly occurred during the execution of a goal are not undone in case
of exceptions, exactly as it normally happens when a predicate fails.
%
Summing up, \texttt{catch/3} is true if:
\begin{itemize}
  \item \texttt{call(\textit{Goal})} is true;\\\\or
  \item \texttt{call(\textit{Goal})} is interrupted by a call to
      \texttt{throw(\textit{Error})} whose \texttt{\textit{Error}} unifies with
      \texttt{\textit{Catcher}}, and the subsequent \texttt{call(\textit{Handler})} is true;
\end{itemize}

If \texttt{\textit{Goal}} is non-deterministic, it can obviously be executed again in
backtracking. However, it should be clear that \texttt{\textit{Handler}} \textit{is possibly
executed just once}, since all the choicepoints of \texttt{\textit{Goal}} are cut in case of
exception.

%------------------------------------------------------------------------------
\subsection{Examples}\label{ssec:basic examples}
%------------------------------------------------------------------------------
As a first, basic example, let us consider the following toy program:
\begin{verbatim}
    p(X):- throw(error), write('---').
    p(X):- write('+++').
\end{verbatim}
and let us consider the behaviour of the program in response to the execution of the goal:
\begin{verbatim}
    ?:- catch(p(0), E, write(E)), fail.
\end{verbatim}
which tries to execute \texttt{p(0)}, catching any exception \texttt{E} and handling the error by
just printing it on the standard output (\texttt{write(E)}).

Perhaps surprisingly, the program will just print \texttt{'error'}, not \texttt{'error---'} or
\texttt{'error+++'}. The reason is that once the exception is raised, the execution of
\texttt{p(X)} is aborted, and after the handler terminates the execution proceeds with the subgoal
which follows \texttt{catch/3}, i.e. \texttt{fail}. So, \texttt{write('---')} is never reached,
nor is \texttt{write('+++')} since all the choicepoints are cut upon exception.

\smallskip
In the following we report a small yet complete set of mini-examples, thought to put in
evidence one single aspect of \tuprolog{} compliance to the ISO standard.

%----------------
\medskip
\textit{\textbf{Example 1:} \texttt{Handler} must be executed maintaining the substitutions
made during the unification process between \texttt{Error} and \texttt{Catcher}}

Program: \texttt{p(0) :- throw(error).}

Query: \texttt{ ?- catch(p(0), E, atom\_length(E, Length)).}

Answer: \texttt{ yes.}

Substitutions: \texttt{E/error}, \texttt{Length/5}

%----------------
\medskip
\textit{\textbf{Example 2:} the selected \texttt{Catcher} must be the nearest in the resolution
tree whose second argument unifies with \texttt{Error}}

Program: \texttt{p(0) :- throw(error).}\\
\mbox{\texttt{~~~~~~~~~~~}}\texttt{p(1).}

Query: \texttt{ ?- catch(p(1), E, fail),  catch(p(0), E, true).}

Answer: \texttt{ yes.}

Substitutions: \texttt{E/error}

%----------------
\medskip
\textit{\textbf{Example 3:} execution must fail if an error occurs during a goal execution and
there is no matching \texttt{catch/3} predicate whose second argument unifies with \texttt{Error}}

Program: \texttt{p(0) :- throw(error).}

Query: \texttt{ ?- catch(p(0), error(X), true).}

Answer: \texttt{ no.}

%----------------
\medskip
\textit{\textbf{Example 4:} execution must fail if \texttt{Handler} is false}

Program: \texttt{p(0) :- throw(error).}

Query: \texttt{ ?- catch(p(0), E, false).}

Answer: \texttt{ no.}

%----------------
\medskip
\textit{\textbf{Example 5:} if \texttt{Goal} is non-deterministic, it is executed again on
backtracking, but in case of exception all the choicepoints must be cut, and \texttt{Handler} must
be executed only once}

Program: \texttt{p(0).}\\
\mbox{\texttt{~~~~~~~~~~~}}\texttt{p(1) :- throw(error).}\\
\mbox{\texttt{~~~~~~~~~~~}}\texttt{p(2).}

Query: \texttt{ ?- catch(p(X), E, true).}

Answer: \texttt{ yes.}

Substitutions: \texttt{X/0}, \texttt{E/error}

Choice: \texttt{ Next solution?}

Answer: \texttt{ yes.}

Substitutions: \texttt{X/1}, \texttt{E/error}

Choice: \texttt{ Next solution?}

Answer: \texttt{ no.}

%----------------
\medskip
\textit{\textbf{Example 6:} execution must fail if an exception occurs in \texttt{Handler}}

Program: \texttt{p(0) :- throw(error).}

Query: \texttt{ ?- catch(p(0), E, throw(err)).}

Answer: \texttt{ no.}

%-----------------------------------------------------------------------
\subsection{Error classification}
\label{ssec:error classification}
%-----------------------------------------------------------------------
So far we have just said that, when an exception is raised, \texttt{throw(\textit{Error})} is
executed, and a matching \texttt{catch/3} is looked for, but no specifications have been given
about the possible structure of the \texttt{\textit{Error}} term.
%
According to the ISO Prolog standard, such a term should follow the pattern
\texttt{error(\textit{Error\_term}, \textit{Implementation\_defined\_term})} where
\texttt{\textit{Error\_term}} is constrained by the standard to a pre-defined set of possible
values, in order to represent the error category: \texttt{\textit{Implementation\_defined\_term}},
instead, is left for implementation-specific details, and could also be omitted.

The error classification induced by \texttt{\textit{Error\_term}} is flat, so as to easily support
pattern matching. Ten error classes are identified by the ISO standard:
\begin{enumerate}
  \item \texttt{instantiation\_error}: when the argument of a predicate or one of its
      components is a variable, while it should be instantiated. A typical example is
      \texttt{X is Y+1} if \texttt{Y} is not instantiated when \texttt{is/2} is evaluated.

  \item \texttt{type\_error(\textit{ValidType}, \textit{Culprit})}: when the type of an
      argument of a predicate, or one of its components, is instantiated, but nevertheless
      incorrect. In this case, \texttt{\textit{ValidType}} represents the expected data type
      (one of \texttt{atom}, \texttt{atomic}, \texttt{byte}, \texttt{callable},
      \texttt{character}, \texttt{evaluable}, \texttt{in\_byte}, \texttt{in\_character},
      \texttt{integer}, \texttt{list}, \texttt{number}, \texttt{predicate\_indicator},
      \texttt{variable}), while \texttt{\textit{Culprit}} is the wrong type found. For
      instance, if a predicate operates on dates and expects months to be represented as
      integers between 1-12, calling the predicate with an argument like \texttt{march}
      instead of \texttt{3} would raise a \texttt{type\_error(integer, march)}, since an
      integer was expected and \texttt{march} was found instead.

  \item \texttt{domain\_error(\textit{ValidDomain}, \textit{Culprit})}: when the argument type
      is correct, but its value falls outside the expected range.
      \texttt{\textit{ValidDomain}} is one of \texttt{character\_code\_list},
      \texttt{close\_option}, \texttt{flag\_value}, \texttt{not\_empty\_list},
      \texttt{not\_less\_than\_zero}, \texttt{io\_mode}, \texttt{operator\_priority},
      \texttt{operator\_specifier}, \texttt{prolog\_flag}, \texttt{read\_option},
      \texttt{source\_sink}, \texttt{stream}, \texttt{stream\_option},\\
      \texttt{stream\_or\_alias}, \texttt{stream\_position}, \texttt{stream\_property},
      \texttt{write\_option}. In the example above, a domain error could be raised if, for
      instance, a value like 13 was provided for the month argument.

  \item \texttt{existence\_error(\textit{ObjectType}, \textit{ObjectName}}: when the
      referenced object to be accessed does not exist. Again, \texttt{\textit{ObjectType}} is
      the type of the unexisting object, and \texttt{\textit{ObjectName}} its name.
      \texttt{\textit{ObjectType}} is \texttt{procedure}, \texttt{source\_sink}, or
      \texttt{stream}. If, for instance, the file \texttt{'usr/goofy'} does not exist, an
      \texttt{existence\_error(stream, 'usr/goofy')} would be raised.

  \item \texttt{permission\_error(\textit{Operation}, \textit{ObjectType}, \textit{Object})}:
      when \texttt{\textit{Operation}} is not allowed on \texttt{\textit{Object}}, which is of
      type \texttt{\textit{ObjectType}}. \texttt{\textit{Operation}} is one of
      \texttt{access}, \texttt{create}, \texttt{input}, \texttt{modify}, \texttt{open},
      \texttt{output}, or \texttt{reposition}, while \texttt{\textit{ObjectType}} falls among
      \texttt{binary\_stream}, \texttt{operator}, \texttt{past\_end\_of\_stream},
      \texttt{private\_procedure}, \texttt{static\_procedure}, \texttt{source\_sink},
      \texttt{stream}, \texttt{flag}, and \texttt{text\_stream}.

  \item \texttt{representation\_error(\textit{Flag})}: when an implementation-defined limit,
      whose category is given by \texttt{\textit{Flag}}, is violated during execution.
      \texttt{\textit{Flag}} is one of \texttt{character}, \texttt{character\_code},
      \texttt{in\_character\_code}, \texttt{max\_arity}, \texttt{max\_integer},
      \texttt{min\_integer}.

  \item \texttt{evaluation\_error(\textit{Error})}: when the evaluation of a function produces
      an exceptional value. Accordingly, \texttt{\textit{Error}} is one of
      \texttt{float\_overflow}, \texttt{int\_overflow}, \texttt{undefined},
      \texttt{underflow}, \texttt{zero\_divisor}.

  \item \texttt{resource\_error(\textit{Resource})}: when the Prolog engine does not have
      enough resources to complete the execution of the current goal. Typical examples are the
      reach of the maximum number of opened files, no further available memory, etc.
      Accordingly, \texttt{resource\_error(Resource)} can be any valid term.

  \item \texttt{syntax\_error(\textit{Message})}: when external data, read from an external
      source, have an incorrect format or cannot be processed for some reason. This kind of
      error typically occurs during \textit{read} operations. \texttt{\textit{Message}} can be
      any valid (simple or compound) term describing the occurred problem.

  \item \texttt{system\_error}: this latter category represents any other unexpected error
      which does not fall in any of the above categories.
\end{enumerate}

%=======================================================================
\section{Implementing Exceptions in tuProlog}
\label{sec:implementing exceptions in tuprolog}
%=======================================================================
Implementing exceptions in \tuprolog{} does not mean just to extend the engine to support the
above mechanisms: given its library-based design, and its intrinsic support to multi-paradigm
programming, adding exceptions in \tuprolog{} has also meant (1) to revise all the existing
libraries, modifying any library predicate so that it raises the appropriate type of exception
instead of just failing; and (2) to carefully define and implement a model to make Prolog
exceptions not only coexist, but also fruitfully operate with the Java (or C\#/.NET) imperative
world, which brings its own concept of exception and its own handling mechanism.

As a preliminary step, the finite-state machine which constitutes the core of the \tuprolog{}
engine was extended with a new \textit{Exception} state, between the existing \textit{Goal
Evaluation} and \textit{Goal Selection} states \cite{iuliani-masterthesis-2009}.

Then, all the \tuprolog{} libraries were revised, according to clearness and efficiency criteria
--- that is, the introduction of the new checks required for proper exception raising should not
reduce performance unacceptably. This issue was particularly relevant for runtime checks, such as
\texttt{existence\_error}s or \texttt{evaluation\_error}s; moreover, since \tuprolog{} libraries
could also be implemented partly in Prolog and partly in Java, careful choices had to be made so
as to introduce such checks at the most adequate level in order to intercept all errors while
maintaining code readability and overall organisation, while guaranteeing efficiency. This led to
intervene with extra Java checks for libraries fully implemented in Java, and with new ''Java
guards'' for predicates implemented in Prolog, keeping the use of Prolog meta-predicates (such as
\texttt{integer/1}) to a minimum.

With respect to the third aspect, which will be discussed more in depth below, one key aspect to
be put in evidence right now concerns the handling of Java objects accessed from the Prolog world
via Javalibrary. At a first sight, one might think of re-mapping Java exceptions and constructs
onto the Prolog one, but this approach is unsatisfactory for three main reasons:
\begin{itemize}
  \item the semantics of the Java mechanism should not be mixed with the Prolog one, and
      vice-versa;
  \item the Java construct admits also a \texttt{finally} clause which has no counterpart in
      ISO Prolog;
  \item the Java catching mechanisms operates hierarchically, while the \texttt{catch/3}
      predicate operates via pattern matching and unification, allowing for multiple
      granularities.
\end{itemize}
For these reasons, supporting Java exceptions from \tuprolog{} programs called for two further,
\textit{ad hoc} predicates \textit{which are not present in ISO Prolog} because ISO Prolog does
not consider multi-paradigm programming: \texttt{java\_throw/1} and \texttt{java\_catch/3}.

%=======================================================================
%-----------------------------------------------------------------------
\subsection{Java exceptions from tuProlog}
\label{ssec:javathrow and javacatch}
%-----------------------------------------------------------------------
The \texttt{java\_throw/1} predicate has the form
\medskip

 \texttt{java\_throw(\textit{JavaException}(\textit{Cause}, \textit{Message}, \textit{StackTrace}))}

\medskip
\noindent where \textit{JavaException} is named after the specific Java exception to be launched
(e.g., \texttt{'java.io.FileNotFoundException'}, and its three arguments represent the typical
properties of any Java exception. More precisely, \texttt{\textit{Cause}} is a string representing
the cause of the exception, or \texttt{0} if the cause is unknown; \texttt{\textit{Message}} is
the message associated to the error (or, again, \texttt{0} if the message is missing);
\texttt{\textit{StackTrace}} is a list of strings, each representing a stack frame.

The \texttt{java\_catch/3} predicate takes the form
\medskip

 \texttt{java\_catch(\textit{JGoal}, [(\textit{Catcher1}, \textit{Handler1}),}

 \texttt{\mbox{~~~~~~~~~~~~~~~~~~}\ldots},

 \texttt{\mbox{~~~~~~~~~~~~~~~~~~}(\textit{CatcherN}, \textit{HandlerN})], \textit{Finally})}

\medskip
\noindent where \texttt{\textit{JGoal}} is the goal (representing a Java operation in the Java
world) to be executed under the protection of the handlers specified in the subsequent list, each
associated to a given type of Java exception and expressed in the form
\texttt{java\_exception(\textit{Cause}, \textit{Message}, \textit{StackTrace})}, with the same
argument semantics explained above. The third argument \texttt{\textit{Finally}} expresses the
homonomous Java clause, and therefore represents the predicate to be executed at the very end
either of the \texttt{\textit{Goal}} or one of the \texttt{\textit{Handler}}s. If no such a clause
is actually needed, the conventional atom (\texttt{'0'}) has to be used as a placeholder.

The predicate behaviour can be informally expressed as follows. First, \textit{\texttt{JGoal}} is
executed. Then, if no exception is raised via \texttt{java\_throw/1}, the
\texttt{\textit{Finally}} goal is executed. If, instead, an exception is raised, all the
choicepoints generated by \textit{\texttt{JGoal}} (in the case of a non-deterministic predicate
like \texttt{java\_object\_bt/3}, of course) are cut: if a matching handler exists, such a handler
is executed, maintaining the variable substitutions. If, instead, no such a handler is found, the
resolution tree is backsearched, looking for a matching \texttt{java\_catch/3} clause: if none
exists, the predicate fails. Upon completion, the \texttt{\textit{Finally}} part is executed
anyway, then the program flow continues with the subgoal following \texttt{java\_catch/3}. As
already said above, side effects possibly generated during the execution of
\textit{\texttt{JGoal}} are \textit{not} undone in case of exception.

So, summing up, \texttt{java\_catch/3} is true if:
\begin{itemize}
  \item \texttt{\textit{JGoal}} and \texttt{\textit{Finally}} are both true;\\\\or
  \item \texttt{call(\textit{JGoal})} is interrupted by a call to \texttt{java\_throw/1} whose
      argument unifies with one of the \texttt{\textit{Catcher}}s, and both the execution of
      the catcher and of the \texttt{\textit{Finally}} clause are true.
\end{itemize}

Even if \texttt{\textit{JGoal}} is a non-deterministic predicate, like
\texttt{java\_object\_bt/3}, and therefore the goal itself can be re-executed in backtracking, in
case of exception only one handler is executed, then all the choicepoints generated by
\texttt{\textit{JGoal}} are removed: so, no further handler would ever be executed for that
exception. In other words, \texttt{java\_catch/3} only protects the execution of
\texttt{\textit{JGoal}}, \textit{not} the handler execution or the \texttt{\textit{Finally}}
execution.

%-----------------------------------------------------------------------
\subsection{Examples}\label{ssec:jexamples}
%-----------------------------------------------------------------------
First, let us consider the following program:
\begin{verbatim}
 ?- java_catch(java_object('Counter', ['MyCounter'], c),
       [('java.lang.ClassNotFoundException'(Cause, Msg, StackTrace),
         write(Msg))],
       write(+++)).
\end{verbatim}
which tries to allocate an instance of \texttt{Counter}, bind it to the atom \texttt{c}, and -- if
everything goes well -- print the \texttt{'+++'} message on the standard output.
%
Indeed, this is precisely what happens if, at runtime, the class \texttt{Counter} is actually
available in the file system. However, it might also happen that, for some reason, the required
class is \textit{not} present in the file system when the above predicate is executed. Then, a
\texttt{'java.lang.ClassNotFoundException'(Cause, Msg, StackTrace)} exception is raised, no side
effects occur -- so, no object is actually created -- and the \texttt{\textit{Msg}} is printed on
the standard output, followed by \texttt{'+++'} as required by the \texttt{\textit{Finally}}
clause. Since the \texttt{\textit{Msg}} in this exception is the name of the missing class, the
global message printed on the console is \texttt{Counter+++}.

\smallskip
In the following we report a small yet complete set of mini-examples, thought to put in evidence
one single aspect of \tuprolog{} compliance to the ISO standard.

%----------------
\medskip
\textit{\textbf{Example 1:} the handler must be executed maintaining the substitutions made during
the unification process between the exception and the catcher: then, the \texttt{Finally} part
must be executed.}
\begin{verbatim}
 ?- java_catch(java_object('Counter', ['MyCounter'], c),
       [('java.lang.ClassNotFoundException'(Cause, Message, _),
         X is 2+3)], Y is 2+5).
\end{verbatim}

Answer: \texttt{ yes.}

Substitutions: \texttt{Cause/0}, \texttt{Message/'Counter'}, \texttt{X/5}, \texttt{Y/7}.

%----------------
\medskip
\textit{\textbf{Example 2:} the selected \texttt{java\_catch/3} must be the nearest in the
resolution tree whose second argument unifies with the launched exception}
\begin{verbatim}
 ?- java_catch(java_object('Counter', ['MyCounter'], c),
       [('java.lang.ClassNotFoundException'(Cause, Message, _),
         true], true),
    java_catch(java_object('Counter', ['MyCounter2'], c2),
       [('java.lang.ClassNotFoundException'(Cause2, Message2, _),
         X is 2+3], true).
\end{verbatim}

Answer: \texttt{ yes.}

Substitutions: \texttt{Cause/0}, \texttt{Message/'Counter'}, \texttt{X/5}, \texttt{C/0},
\texttt{Message2/'Counter'}.

%----------------
\medskip
\textit{\textbf{Example 3:} execution must fail if an exception is raised during the execution of
a goal and no matching \texttt{java\_catch/3} can be found}
\begin{verbatim}
 ?- java_catch(java_object('Counter', ['MyCounter'], c),
      [('java.lang.Exception'(Cause, Message, _), true)], true)).
\end{verbatim}

Answer: \texttt{ no.}

%----------------
\medskip
\textit{\textbf{Example 4:} \texttt{java\_catch/3} must fail if the handler is false}
\begin{verbatim}
 ?- java_catch(java_object('Counter', ['MyCounter'], c),
      [('java.lang.Exception'(Cause, Message, _), false)], true)).
\end{verbatim}

Answer: \texttt{ no.}

%----------------
\medskip
\textit{\textbf{Example 5:} \texttt{java\_catch/3} must fail also if an exception is raised during
the execution of the handler}
\begin{verbatim}
 ?- java_catch(java_object('Counter', ['MyCounter'], c),
      [('java.lang.ClassNotFoundException'(Cause, Message, _),
        java_object('Counter', ['MyCounter'], c))], true).
\end{verbatim}

Answer: \texttt{ no.}

%----------------
\medskip
\textit{\textbf{Example 6:} the \textit{\texttt{Finally}} must be executed also in case of success
of the goal}
\begin{verbatim}
 ?- java_catch(java_object('java.util.ArrayList', [], l),
       [E, true], X is 2+3).
\end{verbatim}

Answer: \texttt{ yes.}

Substitutions: \texttt{X/5}.

%----------------
\medskip
\textit{\textbf{Example 7:} the \textit{\texttt{Handler}} to be executed must be the proper one
among those available in the handlers' list}
\begin{verbatim}
 ?- java_catch(java_object('Counter', ['MyCounter'], c),
     [('java.lang.Exception'(Cause, Message, _), X is 2+3),
      ('java.lang.ClassNotFoundException'(Cause, Message, _), Y is 3+5)],
      true).
\end{verbatim}

Answer: \texttt{ yes.}

Substitutions: \texttt{Cause/0}, \texttt{Message/'Counter'}, \texttt{Y/8}.


%% ---------------------------------------------------------------------------------------
%\section{All the library predicates}
%\label{sec:all predicates}
%% ---------------------------------------------------------------------------------------

%tesi Iuliani da pag 53 a 90 circa

%e poi 108-110 per la parte javalibrary