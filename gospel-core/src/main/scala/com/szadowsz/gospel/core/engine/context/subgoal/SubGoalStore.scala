package com.szadowsz.gospel.core.engine.context.subgoal

import com.szadowsz.gospel.core.data.Term
import com.szadowsz.gospel.core.engine.context.subgoal.tree.{SubGoalLeaf, SubGoalTree}

/** Class to hold sub-goal clauses to evaluate
  *
  * Main Constructor takes an existing Sub-Goal Tree generally
  * generated by a ClauseInfo object or static method.
  *
  * @param subGoals The current sub-goals of the demonstration
  */
private[core] class SubGoalStore(subGoals: SubGoalTree) {
  private var goals: SubGoalTree = subGoals
  private var index: Int = 0
  private var subGoalId: SubGoalId = _


  def this() = {
    this(new SubGoalTree())
  }

  def load(subGoals: SubGoalTree): Boolean = {
    goals = subGoals
    true
  }

  /** Restores the Sub-Goal Store state
    *
    * Backtracks the state to the specified goal pointer so that
    * we can continue our attempts to solve the current theory
    *
    * @param identifier The sub-goal state to backtrack to
    */
  def backTo(identifier: SubGoalId): Option[Term] = {
    popSubGoal(identifier.asInstanceOf[SubGoalId])
    index -= 1 // decrease the index so the term we fetch and return will be correct
    fetch()
  }

  /** Pushes a new sub-goal list onto the stack
    *
    * @param subGoals The sub-goal list to evaluate
    */
  def pushSubGoal(subGoals: SubGoalTree) {
    subGoalId = new SubGoalId(subGoalId, goals, index)
    goals = subGoals
    index = 0
  }

  /** Set an existing identifier as the head and pops all ids that are more recent
    *
    * @param identifier The sub-goal state to go to
    */
  private def popSubGoal(identifier: SubGoalId) {
    goals = identifier.getRoot
    index = identifier.getIndex
    subGoalId = identifier.getParent
  }

  /** Returns the next sub-goal to evaluate */
  def fetch(): Option[Term] = {
    if (haveSubGoals) {
      val goal = goals.getChild(index)
      index += 1

      goal match {
        case g: SubGoalTree =>
          pushSubGoal(g)
          fetch()
        case g: SubGoalLeaf =>
          Option(g.getValue)
      }
    } else {
      // if we have no more sub-goals we go back up a level if able
      if (subGoalId == null) {
        None
      } else {
        popSubGoal(subGoalId)
        fetch()
      }
    }
  }

  def getSubGoals: SubGoalTree = goals

  def getIndexNextSubGoal: Int = index

  def getCurrentID: SubGoalId = subGoalId

  /**
    * Current execution index
    */
  def getCurrentIndex = new SubGoalId(subGoalId, goals, index)

  def haveSubGoals: Boolean = index < goals.size

  override def toString: String = "goals: " + goals + " " + "index: " + index
}